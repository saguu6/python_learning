#Django has built-in validators you can conveniently use to validate your forms (or check for bots!)

#We’ll use the basicapp from the previous lecture and work with the following:
Adding a check for empty fields
Adding a check for a “bot”
Adding a clean method for the entire form.

#Form class

class FormName(forms.Form):
    name = forms.CharField()
    email = forms.EmailField()
    verify_email = forms.EmailField(label='Enter your email again')
    text = forms.CharField(widget=forms.Textarea)
    botcatcher = forms.CharField(required=False,widget=forms.HiddenInput)

#to use built in Validation

from django.core import validators

botcatcher = forms.CharField(required=False,widget=forms.HiddenInput,validators=[validators.MaxLengthValidator(0)])

#we can also write custom Validation
#written outside the class  which can can used for any form validation
def check_for_z(value):  #here value must be passed
   if value[0].lower() != 'z':
         raise forms.ValidationError("name needs to start with 'z'"

#inside class used
name = forms.CharField(validators=[check_for_z])

#inside we can write custom validators which will apply only for that form

#for specific field
#we can write Validation

#use  function clean() or clean_fieldname() for Validation
#clean() is used for whole form Validation
#clean_fieldname() is used for specific field in the form

# def clean_botcatcher(self):
  #     botcatcher = self.cleaned_data['botcatcher']
  #     if len(botcatcher) > 0:
  #         raise forms.ValidationError("GOatcha bOTT")
  #     return botcatcher

  def clean(self):
      all_clean_data = super().clean()
      email = all_clean_data['email']
      vemail = all_clean_data['verify_email']

      if email != vemail:
          raise forms.ValidationError("email doesnot match")
